---
title: "9.3 Atributos y m√©todos"
tags: ""
---

# Atributos y m√©todos

Si hay algo que ilustre el potencial de la POO esa es la capacidad de definir variables y funciones dentro de las clases, aunque aqu√≠ se conocen como atributos y m√©todos respectivamente.

## Atributos

A efectos pr√°cticos los atributos no son muy distintos de las variables, la diferencia fundamental es que s√≥lo existen dentro del objeto.

### Atributos din√°micos

Dado que Python es muy flexible los atributos pueden manejarse de distintas formas, por ejemplo se pueden crear din√°micamente (al vuelo) en los objetos.

```python
class Galleta:
    pass

galleta = Galleta()
galleta.sabor = "salado"
galleta.color = "marr√≥n"

print(f"El sabor de esta galleta es {galleta.sabor} "
      f"y el color {galleta.color}")
```

### Atributos de clase

Aunque la flexibilidad de los atributos din√°micos puede llegar a ser muy √∫til, tener que definir los atributos de esa forma es tedioso. Es m√°s pr√°ctico definir unos atributos b√°sicos en la clase. De esa manera todas las galletas podr√≠an tener unos atributos por defecto:

```python
class Galleta:
    chocolate = False

galleta = Galleta()

if galleta.chocolate:
    print("La galleta tiene chocolate")
else:
    print("La galleta no tiene chocolate")
```

Luego podemos cambiar su valor en cualquier momento:

```python
galleta.chocolate = True

if galleta.chocolate:
    print("La galleta tiene chocolate")
else:
    print("La galleta no tiene chocolate")
```

Por lo menos de esta forma nos aseguraremos de que el atributo chocolate existe en todas las galletas desde el principio. Adem√°s es posible consultar el valor por defecto que deben tener las galletas haciendo referencia al atributo en la definici√≥n de la clase:

```python
print(Galleta.chocolate)
```

Lo curioso es que si cambiamos ese atributo de clase (que no de objeto) a True, las siguientes galletas se crear√°n con chocolate, es decir, habremos modificado las instrucciones de creaci√≥n de los objetos:

```python
class Galleta:
    chocolate = False

Galleta.chocolate = True

galleta = Galleta()

if galleta.chocolate:
    print("La galleta tiene chocolate")
else:
    print("La galleta no tiene chocolate")
```

Ya les gustar√≠a a otros lenguajes ser tan flexibles. üòÅüòÅüòÅ

## M√©todos

Si por un lado tenemos las "variables" de las clases, por otro tenemos sus "funciones", que evidentemente nos permiten definir funcionalidades para llamarlas desde las instancias.

Definir un m√©todo es bastante simple, s√≥lo tenemos que a√±adirlo en la clase y luego llamarlo desde el objeto con los par√©ntesis, como si de una funci√≥n se tratase:

```python
class Galleta:
    chocolate = False

    def saludar():
        print("Hola, soy una galleta muy sabrosa")

galleta = Galleta()
galleta.saludar()
```

Sin embargo, al intentar ejecutar el c√≥digo anterior desde una galleta ver√©is que no funciona. Nos indica que el m√©todo saludar() requiere 0 argumentos pero se est√° pasando uno.

¬øC√≥mo puede ser? Si en ning√∫n momento hemos enviado ninguna informaci√≥n a al galleta...

Lo que tenemos aqu√≠, estimados alumnos, es la diferencia fundamental entre m√©todos de clase y m√©todos de instancia.

Probad a ejecutar el m√©todo llamando a la clase en lugar del objeto:

```python
class Galleta:
    chocolate = False

    def saludar():
        print("Hola, soy una galleta muy sabrosa")

Galleta.saludar()
```

¬°Ahora s√≠ ha funcionado! ¬øC√≥mo es posible? Y m√°s importante, ¬øpor qu√© al llamarlo desde el objeto dice que estamos enviando un argumento?

### Primer argumento self

Los objetos tienen una caracter√≠stica muy importante: son conscientes de que existen. Y no, no es broma.

Cuando se ejecuta un m√©todo desde un objeto (que no desde una clase), se env√≠a un primer argumento impl√≠cito que hace referencia al propio objeto. Si lo definimos en nuestro m√©todo podremos capturarlo y ver qu√© es:

```python
class Galleta:
    chocolate = False

    def saludar(soy_el_propio_objeto):
        print("Hola, soy una galleta muy sabrosa")
        print(soy_el_propio_objeto)

galleta = Galleta()
galleta.saludar()
```

¬øCurioso que haya funcionado verdad? Adem√°s ¬øno os suena de algo ese resultado que muestra el par√°metro que hemos definido? Se trata de la propia representaci√≥n del objeto.

```python
class Galleta:
    chocolate = False

    def saludar(soy_el_propio_objeto):
        print("Hola, soy una galleta muy sabrosa")
        print(soy_el_propio_objeto)

galleta = Galleta()
galleta.saludar()
print(galleta)
```

Pues s√≠, podemos acceder al propio objeto desde el interior de sus m√©todos. Lo √∫nico que como este argumento hace referencia al objeto en s√≠ mismo por convenci√≥n se le llama self.

Poder acceder al propio objeto desde un m√©todo es muy √∫til, ya que nos permite acceder a sus atributos. Fijaros, el siguiente c√≥digo no funcionar√≠a como esperamos:

```python
class Galleta:
    chocolate = False

    def chocolatear(self):
        chocolate = True

galleta = Galleta()
galleta.chocolatear()
print(galleta.chocolate)
```

En cambio, si hacemos ver que self es el propio objeto...

```python
class Galleta:
    chocolate = False

    def chocolatear(self):
        self.chocolate = True

galleta = Galleta()
galleta.chocolatear()
print(galleta.chocolate)
```

¬øNo es interesante? Da la sensaci√≥n como os dec√≠a antes de que las instancias tienen que saber quienes son porque sino no pueden acceder sus atributos internos y por eso tienen que enviarse asimismas a los m√©todos.

Sea como sea con este ejemplo podemos entender que por defecto el valor de un atributo se busca en la clase, pero para modificarlo en la instancia es necesario hacer referencia al objeto.

## M√©todos especiales

Ahora que sabemos crear m√©todos y hemos aprendido para qu√© sirve el argumento self, es momento de introducir algunos m√©todos especiales de las clases.

Se llaman especiales porque la mayor√≠a ya existen de forma oculta y sirven para tareas espec√≠ficas.

### Constructor

El constructor es un m√©todo que se llama autom√°ticamente al crear un objeto, se define con el nombre init:

```python
class Galleta:

    def __init__(self):
        print("Soy una galleta acabada de hornear!")

galleta = Galleta()
```

La finalidad del constructor es, como su nombre indica, construir los objetos. Por esa raz√≥n permite sobreescribir el m√©todo que crea los objetos, permiti√©ndonos enviar datos desde el principio para construirlo:

```python
class Galleta:
    chocolate = False

    def __init__(self, sabor, color):
        self.sabor = sabor
        self.color = color
        print(f"Se acaba de crear una galleta {self.color} y {self.sabor}.")

galleta_1 = Galleta("marr√≥n", "amarga")
galleta_2 = Galleta("blanca", "dulce")
```

Como los m√©todos se comportan como funciones tienen sus mismas caracter√≠sticas, permiti√©ndonos definir valores nulos, valores por posici√≥n y nombre, argumentos indeterminadas, etc.

### Destructor

Si existe un constructor tambi√©n debe existir un destructor que se llame al eliminar el objeto para que encargue de las tareas de limpieza como vaciar la memoria. Ese es el papel del m√©todo especial del. Es muy raro sobreescribir este m√©todo porque se maneja autom√°ticamente, pero es interesante saber que existe.

Todos los objetos se borran autom√°ticamente de la memoria al finalizar el programa, aunque tambi√©n podemos eliminarlos autom√°ticamente pas√°ndolos a la funci√≥n del():

```python
class Galleta:

    def __del__(self):
        print("La galleta se est√° borrando de la memoria")

galleta = Galleta()

del(galleta)
```

En este punto vale comentar algo respecto a los m√©todos especiales como √©ste, y es que pese a que tienen accesores en forma de funci√≥n para facilitar su llamada, es totalmente posible ejecutarlos directamente como si fueran m√©todos normales:

```python
class Galleta:

    def __del__(self):
        print("La galleta se est√° borrando de la memoria")

galleta = Galleta()

galleta.__del__()
```

Si ten√©is memoria seguro que ahora mismo os est√°is acordando de funciones como str() y len(), y es que en efecto, esas tambi√©n son accesores de los m√©todos especiales str y len que tienen los objetos.

### String

El m√©todo str es el que devuelve la representaci√≥n de un objeto en forma de cadena. Un momento en que se llama autom√°ticamente es cuando imprimirmos una variable por pantalla.

Por defecto los objetos imprimen su clase y una direcci√≥n de memoria, pero eso puede cambiarse sobreescribiendo el comportamiento:

```python
class Galleta:

    def __init__(self, sabor, color):
        self.sabor = sabor
        self.color = color

    def __str__(self):
       return f"Soy una galleta {self.color} y {self.sabor}."

galleta = Galleta("dulce", "blanca")

print(galleta)
print(str(galleta))
print(galleta.__str__())
```

Hay que tener en cuenta que este m√©todo debe devolver la cadena en lugar de mostrar algo por pantalla, ese es el funcionamiento que se espera de √©l.

### Length

Finalmente otro m√©todo especial interesante es el que devuelve la longitud. Normalmente est√° ligado a colecciones, pero nada impide definirlo en una clase. Y s√≠, digo definirlo y no redefinirlo porque por defecto no existe en los objetos aunque sea el que se ejecuta al pasarlos a la funci√≥n len().

```python
class Cancion:

    def __init__(self, autor, titulo, duracion):  # en segundos
        self.duracion = duracion

    def __len__(self):
       return self.duracion

cancion = Cancion("Queen", "Don't Stop Me Now", 210)

print(len(cancion))
print(cancion.__len__())
```

Mientras devolvamos un n√∫mero, este m√©todo no deber√≠a dar problemas.
